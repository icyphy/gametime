<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.analyzer &mdash; GameTime 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GameTime
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">GameTime</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GameTime</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../src.html">src</a></li>
      <li class="breadcrumb-item active">src.analyzer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.analyzer</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="kn">import</span> <span class="nn">clang_helper</span>
<span class="kn">import</span> <span class="nn">nx_helper</span>
<span class="kn">import</span> <span class="nn">pulp_helper</span>
<span class="kn">from</span> <span class="nn">defaults</span> <span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">file_helper</span> <span class="kn">import</span> <span class="n">remove_all_except</span>
<span class="kn">from</span> <span class="nn">gametime_error</span> <span class="kn">import</span> <span class="n">GameTimeError</span>
<span class="kn">from</span> <span class="nn">nx_helper</span> <span class="kn">import</span> <span class="n">Dag</span><span class="p">,</span> <span class="n">write_dag_to_dot_file</span>
<span class="kn">from</span> <span class="nn">path</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">path_analyzer</span> <span class="kn">import</span> <span class="n">PathAnalyzer</span>
<span class="kn">from</span> <span class="nn">project_configuration</span> <span class="kn">import</span> <span class="n">ProjectConfiguration</span>
<span class="kn">from</span> <span class="nn">path_generator</span> <span class="kn">import</span> <span class="n">PathGenerator</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dot</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">eye</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">det</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">slogdet</span>

<span class="kn">from</span> <span class="nn">backend.flexpret_backend.flexpret_backend</span> <span class="kn">import</span> <span class="n">FlexpretBackend</span>
<span class="kn">from</span> <span class="nn">backend.x86_backend.x86_backend</span> <span class="kn">import</span> <span class="n">X86Backend</span>
<span class="kn">from</span> <span class="nn">backend.backend</span> <span class="kn">import</span> <span class="n">Backend</span>
<span class="kn">from</span> <span class="nn">smt_solver.extract_labels</span> <span class="kn">import</span> <span class="n">find_labels</span>

<span class="sd">&quot;&quot;&quot;Defines a class that maintains information about the code being analyzed,</span>
<span class="sd">such as the name of the file that contains the code being analyzed and</span>
<span class="sd">the basis paths in the code.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">&quot;&quot;&quot;See the LICENSE file, located in the root directory of</span>
<span class="sd">the source distribution and</span>
<span class="sd">at http://verifun.eecs.berkeley.edu/gametime/about/LICENSE,</span>
<span class="sd">for details on the GameTime license and authors.</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Analyzer"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer">[docs]</a><span class="k">class</span> <span class="nc">Analyzer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maintains information about the code being analyzed, such as</span>
<span class="sd">    the name of the file that contains the code being analyzed</span>
<span class="sd">    and the basis paths of the code.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        project_config:</span>
<span class="sd">            Object that represents the configuration of a GameTime project.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_config</span><span class="p">:</span> <span class="n">ProjectConfiguration</span><span class="p">):</span>
        <span class="c1">### CONFIGURATIONS ###</span>
        <span class="c1">#: :class:`~gametime.projectConfiguration.ProjectConfiguration` object</span>
        <span class="c1">#: that represents the configuration of a GameTime project.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="p">:</span> <span class="n">ProjectConfiguration</span> <span class="o">=</span> <span class="n">project_config</span>

        <span class="c1">### GRAPH INFORMATION ###</span>
        <span class="c1">#: Data structure for the DAG of the code being analyzed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="p">:</span> <span class="n">Dag</span> <span class="o">=</span> <span class="n">Dag</span><span class="p">()</span>

        <span class="c1">### PATHS INFORMATION ###</span>
        <span class="c1">#: Dimension of the vector representing each path.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#: Basis matrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#: Set whose elements are lists of edges that must not be taken</span>
        <span class="c1">#: together along any path through the DAG. For example, the element</span>
        <span class="c1">#: [e1, e2] means &quot;if you take e1, you cannot take e2&quot; and</span>
        <span class="c1">#: &quot;if you take e2, you cannot take e1&quot;.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_exclusive_constraints</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#: List whose elements are lists of edges that must be taken together,</span>
        <span class="c1">#: if at least one is taken along a path through the DAG. For example,</span>
        <span class="c1">#: the element [e1, e2] means &quot;if you take e1, then you take e2&quot;.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_bundled_constraints</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Number of `bad&#39; rows in the basis matrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_bad_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># List of the Path objects associated with all_temp_files basis paths</span>
        <span class="c1"># generated so far.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># List of lists, each of which is a list of IDs of the nodes in</span>
        <span class="c1"># the DAG along each basis path. Each ID is a string. The lists are</span>
        <span class="c1"># arranged in the same order as the Path objects associated with</span>
        <span class="c1"># the basis paths are arranged in the `basis_paths&#39; list.</span>
        <span class="c1"># This list is maintained for efficiency purposes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Specify default parameters for the values used with</span>
        <span class="c1"># --ob_extraction flag. The values are outputted only</span>
        <span class="c1"># when the flag is used.</span>
        <span class="c1"># Value of mu_max computed for the observed measurements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inferred_mu_max</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># The in predictions is error is 2 * inferredMuMax * errorScaleFactor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_scale_factor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dag_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">backend_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Flexpret&quot;</span><span class="p">:</span> <span class="n">FlexpretBackend</span><span class="p">,</span> <span class="s2">&quot;X86&quot;</span><span class="p">:</span> <span class="n">X86Backend</span><span class="p">}</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">backend</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">backend_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GameTimeError</span><span class="p">(</span><span class="s2">&quot;No valid backend specified&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">:</span> <span class="n">Backend</span> <span class="o">=</span> <span class="n">backend_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">backend</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="p">)</span>

        <span class="c1"># Finally, preprocess the file before analysis.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocesses the file before analysis. The preprocessing steps are:</span>
<span class="sd">        1. Create a temporary directory that will contain the files</span>
<span class="sd">        generated during analysis.</span>
<span class="sd">        2. Copy the source file being analyzed into this temporary directory.</span>
<span class="sd">        3. Run CIL on the copied source file to perform, for example, loop</span>
<span class="sd">        unrolling and function inlining.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the file to be analyzed exists.</span>
        <span class="n">orig_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_orig_file</span>
        <span class="n">project_temp_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_dir</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">orig_file</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">project_temp_dir</span><span class="p">)</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;File to analyze not found: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">orig_file</span>
            <span class="k">raise</span> <span class="n">GameTimeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="c1"># Remove any temporary directory created during a previous run</span>
        <span class="c1"># of the same GameTime project, and create a fresh new</span>
        <span class="c1"># temporary directory.</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">project_temp_dir</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">UNROLL_LOOPS</span><span class="p">:</span>
                <span class="c1"># If a previous run of the same GameTime project produced</span>
                <span class="c1"># a loop configuration file, and the current run involves</span>
                <span class="c1"># unrolling the loops that are configured in the file,</span>
                <span class="c1"># do not remove the file.</span>
                <span class="n">remove_all_except</span><span class="p">([</span><span class="n">config</span><span class="o">.</span><span class="n">TEMP_LOOP_CONFIG</span><span class="p">],</span> <span class="n">project_temp_dir</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remove_all_except</span><span class="p">([],</span> <span class="n">project_temp_dir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">project_temp_dir</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">project_temp_dir</span><span class="p">,</span> <span class="mo">0o777</span><span class="p">)</span> <span class="c1"># make dir read and write by everyone</span>

        <span class="c1"># Make a temporary copy of the original file to preprocess.</span>
        <span class="n">preprocessed_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_file</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">orig_file</span><span class="p">,</span> <span class="n">preprocessed_file</span><span class="p">)</span>

        <span class="n">processing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">processing</span> <span class="o">=</span> <span class="n">clang_helper</span><span class="o">.</span><span class="n">compile_to_llvm_for_analysis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_orig_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_dir</span><span class="p">,</span>
                                                          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">name_orig_no_extension</span><span class="si">}</span><span class="s2">gt&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">included</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">compile_flags</span><span class="p">)</span>

        <span class="c1"># Preprocessing pass: inline functions.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">inlined</span><span class="p">:</span>  <span class="c1"># Note: This is made into a bool rather than a list</span>
            <span class="n">processing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_inliner</span><span class="p">(</span><span class="n">input_file</span><span class="o">=</span><span class="n">processing</span><span class="p">)</span>

        <span class="c1"># Preprocessing pass: unroll loops.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">UNROLL_LOOPS</span><span class="p">:</span>
            <span class="n">processing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_loop_unroller</span><span class="p">(</span><span class="n">compiled_file</span><span class="o">=</span><span class="n">processing</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dag_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">clang_helper</span><span class="o">.</span><span class="n">generate_dot_file</span><span class="p">(</span><span class="n">processing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_dir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocessed_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">processing</span>
        <span class="c1"># We are done with the preprocessing.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preprocessing complete.&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_run_loop_unroller</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiled_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        As part of preprocessing, runs CIL on the source file under</span>
<span class="sd">        analysis to unroll loops. A copy of the file that results from</span>
<span class="sd">        the CIL preprocessing is made and renamed for use by other</span>
<span class="sd">        preprocessing phases, and the file itself is renamed and</span>
<span class="sd">        stored for later perusal.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            compiled_file: str :</span>
<span class="sd">                Path to the original file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Path to unrolled file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preprocessed_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_file</span>

        <span class="c1"># Infer the name of the file that results from the CIL preprocessing.</span>
        <span class="n">unrolled_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">clang_helper</span><span class="o">.</span><span class="n">unroll_loops</span><span class="p">(</span><span class="n">compiled_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_dir</span><span class="p">,</span>
                                                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">name_orig_no_extension</span><span class="si">}</span><span class="s2">gt-unrolled&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preprocessing the file: unrolling loops in the code...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">unrolled_file</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Error running the loop unroller.&quot;</span>
            <span class="k">raise</span> <span class="n">GameTimeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">unrolled_file</span><span class="p">,</span> <span class="n">preprocessed_file</span><span class="p">)</span>
    
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loops in the code have been unrolled.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">unrolled_file</span>

    <span class="k">def</span> <span class="nf">_run_inliner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        As part of preprocessing, runs CIL on the source file under</span>
<span class="sd">        analysis to inline functions. A copy of the file that results from</span>
<span class="sd">        the CIL preprocessing is made and renamed for use by other</span>
<span class="sd">        preprocessing phases, and the file itself is renamed and</span>
<span class="sd">        stored for later perusal.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            input_file: str :</span>
<span class="sd">                Path to input file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Path to inlined file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preprocessed_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_file</span>
        <span class="c1"># Infer the name of the file that results from the CIL preprocessing.</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preprocessing the file: inlining...&quot;</span><span class="p">)</span>

        <span class="n">inlined_file</span> <span class="o">=</span> <span class="n">clang_helper</span><span class="o">.</span><span class="n">inline_functions</span><span class="p">(</span><span class="n">input_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_dir</span><span class="p">,</span>
                                                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">name_orig_no_extension</span><span class="si">}</span><span class="s2">gt-inlined&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inlined_file</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Error running the inliner.&quot;</span>
            <span class="k">raise</span> <span class="n">GameTimeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">inlined_file</span><span class="p">,</span> <span class="n">preprocessed_file</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Inlining complete.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">inlined_file</span>
        
    <span class="c1">### GRAPH FUNCTIONS ###</span>
<div class="viewcode-block" id="Analyzer.create_dag"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.create_dag">[docs]</a>    <span class="k">def</span> <span class="nf">create_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the DAG corresponding to the code being analyzed</span>
<span class="sd">        and dumps the DAG, in DOT format, to a temporary file for further</span>
<span class="sd">        analysis. This method also stores a local copy in a data</span>
<span class="sd">        structure that represents the DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Generating the DAG and associated information...&quot;</span><span class="p">)</span>

        <span class="c1">#TODO: add back construction dag from filepath</span>
        <span class="c1"># if nx_helper.construct_dag(self.dag_path):</span>
        <span class="c1">#     err_msg = &quot;Error running the Phoenix program analyzer.&quot;</span>
        <span class="c1">#     raise GameTimeError(err_msg)</span>

        <span class="n">location</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_dir</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">func</span><span class="si">}</span><span class="s2">.dot&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_dag_from_dot_file</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>


        <span class="n">bitcode</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">bitcode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">get_node_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">nodes_indices</span><span class="p">[</span><span class="n">node</span><span class="p">]))</span>
        <span class="n">find_labels</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bitcode</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_dir</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;All possible labels extracted.&quot;</span><span class="p">)</span>


        <span class="c1"># special case for single node dag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span>

        <span class="n">num_edges_reduced</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edges_reduced</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">num_edges_reduced</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The number of non-special edges is different from the dimension of the path.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">GameTimeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;DAG generated.&quot;</span><span class="p">)</span>
        
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The control-flow graph has </span><span class="si">%d</span><span class="s2"> nodes and </span><span class="si">%d</span><span class="s2"> edges, with at most </span><span class="si">%d</span><span class="s2"> possible paths.&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_paths</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;There are at most </span><span class="si">%d</span><span class="s2"> possible basis paths.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Analyzer.load_dag_from_dot_file"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.load_dag_from_dot_file">[docs]</a>    <span class="k">def</span> <span class="nf">load_dag_from_dot_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the DAG that corresponds to the code being analyzed from a DOT file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            location: str :</span>
<span class="sd">                Location of the file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">nx_helper</span><span class="o">.</span><span class="n">construct_dag</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">modified</span><span class="p">:</span>
            <span class="n">modified_dag_location</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">location_temp_dir</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">func</span><span class="si">}</span><span class="s2">_modified.dot&quot;</span><span class="p">)</span>
            <span class="n">write_dag_to_dot_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="p">,</span> <span class="n">modified_dag_location</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;New CFG outputed to folder.&quot;</span><span class="p">)</span>

        <span class="c1"># Reset variables of this &quot;Analyzer&quot; object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_path_exclusive_constraints</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_path_bundled_constraints</span><span class="p">()</span></div>


    <span class="c1">### BASIS MATRIX FUNCTIONS ###</span>
    <span class="k">def</span> <span class="nf">_init_basis_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the basis matrix.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">RANDOMIZE_INITIAL_BASIS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_randomize_basis_matrix</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_randomize_basis_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomizes the rows of the basis matrix using</span>
<span class="sd">        a Fisher-Yates shuffle.</span>
<span class="sd">        </span>
<span class="sd">        Precondition: The basis matrix has been initialized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_swap_basis_matrix_rows</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_swap_basis_matrix_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swaps two rows of the basis matrix.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            i: </span>
<span class="sd">                Index of one row to swap.</span>
<span class="sd">            j:</span>
<span class="sd">                Index of other row to swap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row_to_swap_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">row_to_swap_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">row_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_to_swap_out</span><span class="p">)</span>

        <span class="n">temp_row_to_swap_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">row_len</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_len</span><span class="p">):</span>
            <span class="n">temp_row_to_swap_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_to_swap_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_len</span><span class="p">):</span>
            <span class="n">row_to_swap_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_to_swap_in</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">row_to_swap_in</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_row_to_swap_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>


    <span class="c1">### PATH GENERATION FUNCTIONS ###</span>
<div class="viewcode-block" id="Analyzer.add_path_exclusive_constraint"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.add_path_exclusive_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">add_path_exclusive_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the edges provided to the list of path-exclusive</span>
<span class="sd">        constraints, if not already present. These edges must not</span>
<span class="sd">        be taken together along any path through the DAG.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            edges: List[Tuple[str, str]] :</span>
<span class="sd">                List of edges to add to the list of path-exclusive constraints.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edges</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_exclusive_constraints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path_exclusive_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Analyzer.add_path_bundled_constraint"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.add_path_bundled_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">add_path_bundled_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the edges provided to the list of path-bundled</span>
<span class="sd">        constraints, if not already present. These edges must</span>
<span class="sd">        be taken together if at least one of them is taken along</span>
<span class="sd">        a path through the DAG.</span>
<span class="sd">        Parameters:</span>
<span class="sd">            edges: List[Tuple[str, str]] :</span>
<span class="sd">                List of edges to add to the list of path-bundled constraints.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edges</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_bundled_constraints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path_bundled_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Analyzer.reset_path_exclusive_constraints"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.reset_path_exclusive_constraints">[docs]</a>    <span class="k">def</span> <span class="nf">reset_path_exclusive_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resets the path-exclusive constraints.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_exclusive_constraints</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Analyzer.reset_path_bundled_constraints"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.reset_path_bundled_constraints">[docs]</a>    <span class="k">def</span> <span class="nf">reset_path_bundled_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resets the path-bundled constraints.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_bundled_constraints</span> <span class="o">=</span> <span class="p">[]</span></div>

    <span class="k">def</span> <span class="nf">_compress_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compresses the path provided: this method converts</span>
<span class="sd">        the provided path to a 0-1 vector that is 1 if a</span>
<span class="sd">        &#39;non-special&#39; edge is along the path, and 0 otherwise.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            path_edges: List[Tuple[str, str]] :</span>
<span class="sd">                Edges along the path to represent with &#39;non-special&#39; edges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            0-1 vector that is 1 if a `non-special&#39; edge is along the path, and 0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">path_edges</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edges_reduced</span><span class="p">]</span>

    <span class="c1">####### Fuctions to FIX</span>
<div class="viewcode-block" id="Analyzer.generate_overcomplete_basis"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.generate_overcomplete_basis">[docs]</a>    <span class="k">def</span> <span class="nf">generate_overcomplete_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates an overcomplete basis so that each feasible path can be</span>
<span class="sd">           written as a liner combination of the paths in the basis so that the</span>
<span class="sd">           L1 norm is at most &#39;k&#39;. This method is for testing purposes</span>
<span class="sd">           only as it exhaustively generates all_temp_files paths in the graph!. Use the</span>
<span class="sd">           function below for a scalable version.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            k: int :</span>
<span class="sd">                Maximum value of L1 norm.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Generating all_temp_files paths&quot;</span><span class="p">)</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">sink</span><span class="p">)</span>
        <span class="n">feasible</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Find minimal overcomplete basis&quot;</span><span class="p">)</span>
        <span class="n">pulp_helper</span><span class="o">.</span><span class="n">find_minimal_overcomplete_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feasible</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="Analyzer.iteratively_find_overcomplete_basis"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.iteratively_find_overcomplete_basis">[docs]</a>    <span class="k">def</span> <span class="nf">iteratively_find_overcomplete_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_paths</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates overcomplete basis such the lenth of the longest</span>
<span class="sd">        feasible path is at most &#39;k&#39;. The basis is computed by iteratively</span>
<span class="sd">        extending the basis with the longest path.  Parameter &#39;initial_paths&#39;</span>
<span class="sd">        specifies the set of paths the iterative algorithm begins with. This</span>
<span class="sd">        can be any set of paths, in practice we use the paths generated by</span>
<span class="sd">        the standard algorithm.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            initial_paths: List[List[Tuple[str, str]]] :</span>
<span class="sd">                A list of initial paths to begin with.</span>
<span class="sd">                </span>
<span class="sd">            k: int :</span>
<span class="sd">                Maximum value of L1 norm.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The set of basis paths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infeasible</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_node_paths</span> <span class="o">=</span> <span class="n">initial_paths</span>
        <span class="n">optimal_bound</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">before_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">length</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ilp_problem</span> <span class="o">=</span> \
                <span class="n">pulp_helper</span><span class="o">.</span><span class="n">find_worst_expressible_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">after_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found a candidate path of length </span><span class="si">%.2f</span><span class="s2"> in </span><span class="si">%d</span><span class="s2"> seconds&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">after_time</span> <span class="o">-</span> <span class="n">before_time</span><span class="p">))</span>

            <span class="n">optimal_bound</span> <span class="o">=</span> <span class="n">length</span>
            <span class="c1"># if the length of the longest path is within the given bound, stop</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span> <span class="k">break</span>

            <span class="n">candidate_path_nodes</span> <span class="o">=</span> <span class="n">path</span>
            <span class="n">candidate_path_edges</span> <span class="o">=</span> <span class="n">Dag</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(</span><span class="n">candidate_path_nodes</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Checking if the found path is feasible...&quot;</span><span class="p">)</span>
            <span class="n">result_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">ilp_problem</span><span class="o">=</span><span class="n">ilp_problem</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">candidate_path_nodes</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_path</span><span class="p">(</span><span class="n">result_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Path is feasible.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_path</span><span class="p">)</span>
                <span class="n">edge_node_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Path is infeasible.&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finding the edges to exclude...&quot;</span><span class="p">)</span>
                <span class="n">infeasible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>
                <span class="n">unsat_core</span> <span class="o">=</span> <span class="n">result_path</span><span class="o">.</span><span class="n">smtQuery</span><span class="o">.</span><span class="n">unsatCore</span>
                <span class="n">exclude_edges</span> <span class="o">=</span> <span class="n">result_path</span><span class="o">.</span><span class="n">get_edges_for_conditions</span><span class="p">(</span><span class="n">unsat_core</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Edges to be excluded found.&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adding a constraint to exclude &quot;</span>
                            <span class="s2">&quot;these edges...&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exclude_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_path_exclusive_constraint</span><span class="p">(</span><span class="n">exclude_edges</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_path_exclusive_constraint</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Constraint added.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found overcomplete basis of size </span><span class="si">%d</span><span class="s2">, yielding bound </span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_node_paths</span><span class="p">),</span> <span class="n">optimal_bound</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span></div>

<div class="viewcode-block" id="Analyzer.generate_basis_paths"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.generate_basis_paths">[docs]</a>    <span class="k">def</span>  <span class="nf">generate_basis_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a list of &quot;Path&quot; objects, each of which represents</span>
<span class="sd">        a basis path of the code being analyzed. The basis &quot;Path&quot; objects</span>
<span class="sd">        are regenerated each time this method is called.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of basis paths of the code being analyzed, each</span>
<span class="sd">            represented by an object of the &quot;Path&quot; class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basis_paths</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">nx_helper</span><span class="o">.</span><span class="n">has_cycles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Loops in the code have been detected.&quot;</span><span class="p">)</span>
            <span class="c1"># logger.warning(&quot;No basis paths have been generated.&quot;)</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Generating the basis paths...&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initializing the basis matrix...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_basis_matrix</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Basis matrix initialized to&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;There are a maximum of </span><span class="si">%d</span><span class="s2"> possible basis paths.&quot;</span> <span class="o">%</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">on_exit</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">infeasible</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Helper function that is called when this method is about to</span>
<span class="sd">            return the basis Path objects, and performs the appropriate</span>
<span class="sd">            pre-exit cleanup. This inner function will be used in two</span>
<span class="sd">            places below, and is defined once to keep the code neat,</span>
<span class="sd">            to prevent deeper indentation, and to reduce confusion.</span>

<span class="sd">            Parameters:</span>
<span class="sd">                start_time :</span>
<span class="sd">                    Time when the generation of basis Path objects was started.</span>
<span class="sd">                infeasible :</span>
<span class="sd">                    Set of infeasible paths.</span>

<span class="sd">            Returns:            </span>
<span class="sd">                List of basis paths of the code being analyzed, each represented by an object of the Path class.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span> <span class="o">=</span> <span class="n">basis_paths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">basis_paths</span><span class="p">]</span>
            <span class="c1"># self.resetPathExclusiveConstraints()</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Time taken to generate paths: </span><span class="si">%.2f</span><span class="s2"> seconds.&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Basis paths generated.&quot;</span><span class="p">)</span>

            <span class="c1"># If we are computing overcomplete basis, use the computed set as</span>
            <span class="c1"># the initial set of paths in the iterative algorithm,</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">OVER_COMPLETE_BASIS</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Iteratively improving the basis&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">infeasible</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_path_exclusive_constraint</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="n">edge_paths</span> <span class="o">=</span> \
                    <span class="p">[</span><span class="n">Dag</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span><span class="p">]</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteratively_find_overcomplete_basis</span><span class="p">(</span>
                    <span class="n">edge_paths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">MAXIMUM_ERROR_SCALE_FACTOR</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Number of paths generated: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Time taken to generate paths: </span><span class="si">%.2f</span><span class="s2"> seconds.&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warn_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Basis matrix has dimensions 1x1. &quot;</span>
                        <span class="s2">&quot;There is only one path through the function &quot;</span>
                        <span class="s2">&quot;under analysis, which is the only basis path.&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warn_msg</span><span class="p">)</span>   
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn_msg</span> <span class="o">=</span> <span class="s2">&quot;Single node CFD with no edge. Only one possible path.&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warn_msg</span><span class="p">)</span>
            <span class="n">basis_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">source</span><span class="p">])]</span>
            <span class="k">return</span> <span class="n">on_exit</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="p">[])</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Collects all_temp_files infeasible paths discovered during the computation</span>
        <span class="n">infeasible</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_row</span><span class="p">,</span> <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">current_row</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bad_rows</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Currently at row </span><span class="si">%d</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;So far, the bottom </span><span class="si">%d</span><span class="s2"> rows of the basis matrix are `bad&#39;.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bad_rows</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;So far, </span><span class="si">%d</span><span class="s2"> candidate paths were found to be unsatisfiable.&quot;</span> <span class="o">%</span> <span class="n">num_paths_unsat</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Basis matrix is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating subdeterminants...&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_paths_unsat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Calculate the subdeterminants only if the replacement of this row has not yet been attempted.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">reset_edge_weights</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edge_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_subdets</span><span class="p">(</span><span class="n">current_row</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculation complete.&quot;</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finding a candidate path using an integer linear program...&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">candidate_path_nodes</span><span class="p">,</span> <span class="n">ilp_problem</span> <span class="o">=</span> <span class="n">pulp_helper</span><span class="o">.</span><span class="n">find_extreme_path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ilp_problem</span><span class="o">.</span><span class="n">obj_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unable to find a candidate path to replace row </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Moving the bad row to the bottom of the basis matrix.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_swap_basis_matrix_rows</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_bad_rows</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Candidate path found.&quot;</span><span class="p">)</span>

            <span class="n">candidate_path_edges</span> <span class="o">=</span> <span class="n">Dag</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(</span><span class="n">candidate_path_nodes</span><span class="p">)</span>
            <span class="n">compressed_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compress_path</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>

            <span class="c1"># Temporarily replace the row in the basis matrix to calculate the new determinant.</span>
            <span class="n">prev_matrix_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">compressed_path</span>
            <span class="n">sign</span><span class="p">,</span> <span class="n">new_basis_matrix_log_det</span> <span class="o">=</span> <span class="n">slogdet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">)</span>
            <span class="n">new_basis_matrix_det</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">new_basis_matrix_log_det</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Absolute value of the new determinant: </span><span class="si">%g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">new_basis_matrix_det</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="n">DETERMINANT_THRESHOLD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">DETERMINANT_THRESHOLD</span>
            <span class="n">MAX_INFEASIBLE_PATHS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">MAX_INFEASIBLE_PATHS</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">new_basis_matrix_log_det</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">))</span> <span class="ow">or</span>
                    <span class="n">new_basis_matrix_det</span> <span class="o">&lt;</span> <span class="n">DETERMINANT_THRESHOLD</span> <span class="ow">or</span>
                    <span class="n">num_paths_unsat</span> <span class="o">&gt;=</span> <span class="n">MAX_INFEASIBLE_PATHS</span><span class="p">):</span>  <span class="c1"># If row is bad</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">new_basis_matrix_det</span> <span class="o">&lt;</span> <span class="n">DETERMINANT_THRESHOLD</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">new_basis_matrix_log_det</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">))):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Determinant is too small.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unable to find a path that makes the determinant non-zero.&quot;</span><span class="p">)</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Moving the bad row to the bottom of the basis matrix.&quot;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_matrix_row</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_swap_basis_matrix_rows</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_bad_rows</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Row is good, check feasibility</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Possible replacement for row found.&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Checking if replacement is feasible...&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">result_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">ilp_problem</span><span class="o">=</span><span class="n">ilp_problem</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">candidate_path_nodes</span><span class="p">)</span>
  
                <span class="c1"># feasibility test</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_path</span><span class="p">(</span><span class="n">result_path</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;gen-basis-path-row</span><span class="si">{</span><span class="n">current_row</span><span class="si">}</span><span class="s1">-attempt</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
                    <span class="c1"># Sanity check:</span>
                    <span class="c1"># A row should not be replaced if it replaces a good row and decreases the determinant. However, replacing a bad row and decreasing the determinant is okay. (TODO: Are we actually doing this?)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Replacement is feasible.&quot;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Row </span><span class="si">%d</span><span class="s2"> replaced.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">basis_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_path</span><span class="p">)</span>
                    <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Replacement is infeasible.&quot;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adding a constraint to exclude these edges...&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_path_exclusive_constraint</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>
                    <span class="n">infeasible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Constraint added.&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_matrix_row</span>
                    <span class="n">num_paths_unsat</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="o">.</span><span class="n">PREVENT_BASIS_REFINEMENT</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_exit</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">infeasible</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Refining the basis into a 2-barycentric spanner...&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">is_two_barycentric</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">refinement_round</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">is_two_barycentric</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Currently in round </span><span class="si">%d</span><span class="s2"> of refinement...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">refinement_round</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="n">is_two_barycentric</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">current_row</span><span class="p">,</span> <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">good_rows</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bad_rows</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">current_row</span> <span class="o">&lt;</span> <span class="n">good_rows</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Currently at row </span><span class="si">%d</span><span class="s2"> out of </span><span class="si">%d</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">good_rows</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;So far, </span><span class="si">%d</span><span class="s2"> candidate paths were found to be unsatisfiable.&quot;</span> <span class="o">%</span> <span class="n">num_paths_unsat</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Basis matrix is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating subdeterminants...&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">num_paths_unsat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Calculate the subdeterminants only if the replacement of this row has not yet been attempted.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">reset_edge_weights</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edge_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_subdets</span><span class="p">(</span><span class="n">current_row</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculation complete.&quot;</span><span class="p">)</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finding a candidate path using an integer linear program...&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">candidate_path_nodes</span><span class="p">,</span> <span class="n">ilp_problem</span> <span class="o">=</span> <span class="n">pulp_helper</span><span class="o">.</span><span class="n">find_extreme_path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">ilp_problem</span><span class="o">.</span><span class="n">obj_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unable to find a candidate path to replace row </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">continue</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Candidate path found.&quot;</span><span class="p">)</span>
                <span class="n">candidate_path_edges</span> <span class="o">=</span> <span class="n">Dag</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(</span><span class="n">candidate_path_nodes</span><span class="p">)</span>
                <span class="n">compressed_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compress_path</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>

                <span class="n">sign</span><span class="p">,</span> <span class="n">old_basis_matrix_log_det</span> <span class="o">=</span> <span class="n">slogdet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">)</span>
                <span class="n">old_basis_matrix_det</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">old_basis_matrix_log_det</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Absolute value of the old determinant: </span><span class="si">%g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">old_basis_matrix_det</span><span class="p">)</span>

                <span class="c1"># Temporarily replace the row in the basis matrix</span>
                <span class="c1"># to calculate the new determinant.</span>
                <span class="n">prev_matrix_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">compressed_path</span>
                <span class="n">sign</span><span class="p">,</span> <span class="n">new_basis_matrix_log_det</span> <span class="o">=</span> <span class="n">slogdet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">)</span>
                <span class="n">new_basis_matrix_det</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">new_basis_matrix_log_det</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Absolute value of the new determinant: </span><span class="si">%g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">new_basis_matrix_det</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">new_basis_matrix_det</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">old_basis_matrix_det</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Possible replacement for row found.&quot;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Checking if replacement is feasible...&quot;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="n">result_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">ilp_problem</span><span class="o">=</span><span class="n">ilp_problem</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">candidate_path_nodes</span><span class="p">)</span>
                    <span class="n">basis_paths</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_path</span>
                    <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span>
                    
                    <span class="c1">#feasibility test</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_path</span><span class="p">(</span><span class="n">result_path</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;gen-basis-path-replace-candid-</span><span class="si">{</span><span class="n">current_row</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">good_rows</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Replacement is feasible.&quot;</span><span class="p">)</span>
                        <span class="n">is_two_barycentric</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">basis_paths</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_path</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Row </span><span class="si">%d</span><span class="s2"> replaced.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Replacement is infeasible.&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_path_exclusive_constraint</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adding a constraint to exclude these edges...&quot;</span><span class="p">)</span>
                        <span class="n">infeasible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate_path_edges</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Constraint added.&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_matrix_row</span>
                        <span class="n">num_paths_unsat</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No replacement for row </span><span class="si">%d</span><span class="s2"> found.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">current_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_matrix_row</span>
                    <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">num_paths_unsat</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="n">refinement_round</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Basis refined.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">on_exit</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">infeasible</span><span class="p">)</span></div>

    <span class="c1">### PATH GENERATION HELPER FUNCTIONS ###</span>
    <span class="k">def</span> <span class="nf">_calculate_subdets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of weights, where weight i is assigned to</span>
<span class="sd">        edge i. The weights assigned to the `non-special&#39; edges are</span>
<span class="sd">        subdeterminants of the basis matrix without row i and column j:</span>
<span class="sd">        column j corresponds to the `non-special&#39; edge j.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            row: int :</span>
<span class="sd">                Row to ignore.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of weights as specified above.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges_reduced</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edges_reduced</span>
        <span class="n">edges_reduced_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edges_reduced_indices</span>

        <span class="n">edge_weight_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">num_edges</span>

        <span class="n">row_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">))</span>
        <span class="n">row_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">):</span>
            <span class="n">col_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span><span class="p">))</span>
            <span class="n">col_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">sub_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">[</span><span class="n">row_list</span><span class="p">][:,</span> <span class="n">col_list</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">sub_matrix</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Compute the subdeterminant of this submatrix.</span>
                <span class="n">subdet</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">sub_matrix</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">row</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">edge_weight</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">subdet</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">subdet</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Special case of a 1x1 matrix, or of code under analysis</span>
                <span class="c1"># with only one path that goes through.</span>
                <span class="n">edge_weight</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Assign this edge weight to the proper `non-special&#39; edge.</span>
            <span class="n">edge_weight_list</span><span class="p">[</span><span class="n">edges_reduced_indices</span><span class="p">[</span><span class="n">edges_reduced</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">edge_weight</span>

        <span class="k">return</span> <span class="n">edge_weight_list</span>


<div class="viewcode-block" id="Analyzer.estimate_edge_weights"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.estimate_edge_weights">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates the weights on the edges of the DAG, using the values</span>
<span class="sd">        of the basis &quot;Path&quot; objects. The result is stored in the instance</span>
<span class="sd">        variable &quot;edgeWeights&quot;.</span>
<span class="sd">        </span>
<span class="sd">        Precondition: The basis paths have been generated and have values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">reset_edge_weights</span><span class="p">()</span>

        <span class="n">basis_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">basis_path</span><span class="o">.</span><span class="n">measured_value</span> <span class="k">for</span> <span class="n">basis_path</span>
                        <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span><span class="p">]</span>
        <span class="c1"># By default, we assume a value of 0 for each of the rows in</span>
        <span class="c1"># the basis matrix that no replacement could be found for</span>
        <span class="c1"># (the `bad&#39; rows in the basis matrix).</span>
        <span class="n">basis_values</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_dimension</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_values</span><span class="p">))</span>

        <span class="c1"># Estimate the weights on the `non-special&#39; edges of the graph.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Estimating the weights on the `non-special&#39; edges...&quot;</span><span class="p">)</span>
        <span class="n">reduced_edge_weights</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">),</span> <span class="n">basis_values</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Weights estimated.&quot;</span><span class="p">)</span>

        <span class="c1"># Generate the list of edge weights that the integer linear</span>
        <span class="c1"># programming problem will use.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Generating the list of weights on all_temp_files edges...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">reduced_edge_index</span><span class="p">,</span> <span class="n">reduced_edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edges_reduced</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edge_weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">edges_reduced_indices</span><span class="p">[</span><span class="n">reduced_edge</span><span class="p">]]</span> <span class="o">=</span> \
                <span class="n">reduced_edge_weights</span><span class="p">[</span><span class="n">reduced_edge_index</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;List generated.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Analyzer.generate_paths"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.generate_paths">[docs]</a>    <span class="k">def</span> <span class="nf">generate_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PathGenerator</span><span class="o">.</span><span class="n">generate_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">### MEASUREMENT FUNCTIONS ####</span>
<div class="viewcode-block" id="Analyzer.measure_basis_paths"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.measure_basis_paths">[docs]</a>    <span class="k">def</span> <span class="nf">measure_basis_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Measure all generated BASIS_PATHS again</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span><span class="p">)):</span>
            <span class="n">p</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measure_path</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;basis_path</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Analyzer.measure_path"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.measure_path">[docs]</a>    <span class="k">def</span> <span class="nf">measure_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Measure the Path if never measured before. If no name was set, the parameter output_name is used. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            path: Path :</span>
<span class="sd">                The path object</span>
<span class="sd">            output_name: str :</span>
<span class="sd">                Name for this path.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Measured cycle count for PATH.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">path_analyzer</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">path</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">output_name</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">output_name</span>
            <span class="n">path_analyzer</span><span class="p">:</span> <span class="n">PathAnalyzer</span> <span class="o">=</span> <span class="n">PathAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preprocessed_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_config</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">output_name</span><span class="p">)</span>
            <span class="n">path</span><span class="o">.</span><span class="n">path_analyzer</span> <span class="o">=</span> <span class="n">path_analyzer</span>
            
            <span class="n">path_analyzer</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">path_analyzer</span>
            <span class="n">value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">measured_value</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">path_analyzer</span><span class="o">.</span><span class="n">measure_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">))</span>
            <span class="n">path</span><span class="o">.</span><span class="n">set_measured_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">measured_value</span></div>

<div class="viewcode-block" id="Analyzer.measure_paths"><a class="viewcode-back" href="../../src.html#src.analyzer.Analyzer.measure_paths">[docs]</a>    <span class="k">def</span> <span class="nf">measure_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Path</span><span class="p">],</span> <span class="n">output_name_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Measure the list of PATHS. Using prefix and index as name if none is given.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            paths: list[Path] :</span>
<span class="sd">                List of paths to measure.</span>
<span class="sd">            output_name_prefix: str :</span>
<span class="sd">                Prefix to use for the name of each path</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of measured values for the paths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)):</span>
            <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">output_name_prefix</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">measure_path</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">output_name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span></div></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Colin Cai, Abdalla Eltayeb, Shaokai Lin, Andrew Zhang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>