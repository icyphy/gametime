#!/usr/bin/env python
import os
import shutil
import time

import re
from backend.backend import Backend
from backend.generate_executable import generate_executable
from project_configuration import ProjectConfiguration
from defaults import logger
from typing import List
from gametime_error import GameTimeError


class FlexpretBackend(Backend):
        
    timing_func = """
static inline unsigned long long read_cycle_count() {
    unsigned long long cycles;
    asm volatile ("rdcycle %0" : "=r" (cycles));
    return cycles;
}
"""

    def __init__(self, project_config: ProjectConfiguration):
        super(FlexpretBackend, self).__init__(project_config, "Flexpret")

    def generate_executable_c(self, filepath: str, func_name: str, inputs: str, measure_folder: str) -> str:
        exec_file = generate_executable(filepath, measure_folder, func_name, inputs, self.timing_func, True)
        return exec_file
              

    def c_file_to_mem (self, stored_folder: str, file_name: str, c_filepath: str) -> str:
        """
        Use same Make file mechanism as Flexpret to generate .mem file from .c
        """
        # copy the MAKEFILE in FLEXPRET repository to the same folder as .o file
        makefile_template_path = os.path.join(self.project_config.gametime_path, "src", "backend", "flexpret_backend", "Makefile")

        makefile_path = os.path.join(stored_folder, "Makefile")

        shutil.copy(makefile_template_path, makefile_path)
        os.chmod(stored_folder, 0o755)  # Read, write, and execute for the user; read and execute for others
        os.chmod(makefile_path, 0o755)  # Same as above

        # gather all the files needed to run Make, particularly all the possible .c/.o files
        # #TODO: maybe user should provide all the paths here?
        # context_path_from_flexpret_backend = f'{self.project_config.location_orig_dir}'
        # context_folder = os.listdir(context_path_from_flexpret_backend)
        # context_files = []
        # for entry in context_folder:
        #     if ((not entry == self.project_config.name_orig_file) and entry.endswith('.c')) or entry.endswith('.o'):
        #         context_files.append(f'{context_path_from_flexpret_backend}/{entry}')
        
        context_files = self.project_config.included.copy()

        # add the generated .o file
        context_files.append(c_filepath)
        app_sources = " ".join(context_files)

        # run make to generate .mem file
        cwd = os.getcwd()
        os.chdir(stored_folder)
        # the three ".." is to get from the stored folder file to the simulated file, equivalent of stored_folder = {simulated_file_path}/{app name}gt/{path name}/{Flexpret}
        os.system(f'make FLEXPRET_ROOT_DIR={os.path.join("..", "..", "..", self.project_config.gametime_file_path, self.project_config.gametime_flexpret_path)} '
                  f'NAME={file_name} APP_SOURCES={app_sources}')
        os.chdir(cwd)
        
        mem_file_path = os.path.join(stored_folder, f"{file_name}.mem")
        while not os.path.exists(mem_file_path):
            logger.info('Waiting for .mem file to be generated by FlexPRET')
            time.sleep(5)

        return mem_file_path

    def run_backend_and_parse_output(self, stored_folder: str,  mem_filepath: str) -> int:
        """
        Run simulation on the .mem file generated. The measurements are stored in measure.out
        Equivalent to: os.system(f"(cd {dir path of .mem file} && fp-emu --measure +ispm={file_name}.mem)")

        :param stored_folder: the file path of the folder where .mem file is stored
        :param file_name: the file name of the .mem file
        :return the measurement value
        """
        cwd = os.getcwd()
        os.chdir(stored_folder)
        os.system(f"fp-emu +ispm={mem_filepath} > measure.out")
        os.chdir(cwd)

        out_filepath = os.path.join(stored_folder, "measure.out")
        while not os.path.exists(out_filepath):
            print('Waiting for measure.out file to be generated by FlexPRET')
            time.sleep(5)

        with open(out_filepath, "r") as out_file:
            lines = out_file.readlines()
        
        #flexpret console output has two extra lines at the end
        print_line = lines[-3] if lines else ''

        match = re.search(r'\d+$', print_line)
        
        if match:
            extracted_integer = int(match.group())
            return extracted_integer
        else:
            raise GameTimeError("The measure output file is ill-formatted")

    def measure(self, inputs: str, measure_folder: str) -> int:
        """
        Perform measurement using the simulator.
        :param inputs: the inputs to drive down a PATH in a file
        :param measure_folder: all generated files will be stored in MEASURE_FOLDER/{name of simulator}
        :return the measured value of path
        """
        stored_folder: str = measure_folder
        filepath: str = self.project_config.location_orig_file
        func_name: str = self.project_config.func
        c_filepath: str = self.generate_executable_c(filepath, func_name, inputs, measure_folder)
        mem_filepath: str = self.c_file_to_mem(stored_folder, "driver", c_filepath)
        cycle_count: int = -1
        try:
            cycle_count: int = self.run_backend_and_parse_output(stored_folder, mem_filepath)
        except EnvironmentError as e:
            err_msg: str = ("Error in measuring the cycle count of a path in Flexpret: %s" % e)
            logger.info(err_msg)
        return cycle_count